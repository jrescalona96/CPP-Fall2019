# Project #1 : Job Scheduler

### Simulating Job Scheduler of the Operating Systems by programming the following four scheduling algorithms that we covered in the class:

- a. First-Come-First-Serve (FCFS)
- b. Shortest-Job-First (SJF)
- c. Round-Robin with Time Slice = 2 (RR-2)
- d. Round-Robin with Time Slice = 5 (PR-5)

You can use either Java or your choice of programming language for the implementation. The objective of this project is to help student understand how above four job scheduling algorithms operates by implementing the algorithms, and conducting a performance analysis of them based on the performance measure of their average turnaround times (of all jobs) for each scheduling algorithm using multiple inputs. Output the details of each algorithm’s execution. You need to show which jobs are selected at what times as well as their starting and stopping burst values. You can choose your display format, for examples, you can display the results of each in **Schedule Table** or **Gantt Chart** format (as shown in the class notes). The project will be divided into three parts (phases) to help you to accomplish above tasks in in a systematic and scientific fashion: Design and Testing, Implementation, and Performance Analysis.

The program will read process burst times from a file (job.txt) – this file will be generated by you. Note that you need to generate multiple testing cases (with **inputs of 5 jobs, 10 jobs, 15 jobs, 20 jobs, 25 jobs and 30 jobs**). A sample input file of five jobs is given as follows (burst time in ms):

> [Begin of job.txt]
>
> Job1
>
> 7
>
> Job2
>
> 18
>
> Job3
>
> 10
>
> Job4
>
> 4
>
> Job5
>
> 12
>
> [End of job.txt]

### Note: you can assume that:

> (1) There are no more than 30 jobs in the input file (job.txt).
>
> (2) Processes arrive in the order they are read from the file for FCFS, RR-2 and RR-5.
>
> (3) All jobs arrive at time 0 for SJF.
>
> (4) FCFS use the order of the jobs, Job1, Job2, Job3, …

You can implement the algorithms in your choice of data structures based on the program language of your choice. Note that you always try your best to give the most efficient program for each problem. The size of the input will be limited to be within 30 jobs.

# Submission Instructions:

- turn in the following on @blackboard.cpp.edu after the completion of all three parts, part 1, part 2 and part 3
  > (1) four program (your choice of programming language with proper documentation) files
  >
  > (2) this document (complete all the answers)

---

# Pseudocode

## First-Come-First-Serve (FCFS)

> startTime = 0, endtime = 0
>
> while !EOF
>
> > > read job name
> > >
> > > let timeToFinish = burst time of job
> > >
> > > let startTime = endTime;
> > >
> > > let endTime = startTime + timeToFinish
> > >
> > > let status = endTime
> > >
> > > print job details as row in Schedule Table

## ShortestJobFirst

> startTime = 0, endtime = 0
>
> read and store jobs into HashMap using **TIME as KEY**
>
> > store values to ArrayList
> >
> > sort ArrayList
>
> Iterate over ArrayList to use val as key for each HashMap.get(key)
>
> > let jobName = HashMap.get(key)
> >
> > let jobTime = key
> >
> > let timeToFinish = burst time of job
> >
> > let startTime = endTime;
> >
> > let endTime = startTime + timeToFinish
> >
> > let status = endTime
> >
> > print job details as row in Schedule Table

## Round Robin : slices = 2 & slice = 5

> startTime = 0, endtime = 0, slice = time per job
>
> push all jobs to nameQueue & timeQueue
>
> while until queue is empty
>
> > pop from nameQueue
> >
> > pop burstTime
> >
> > let burstTime = burstTime - slice
> >
> > if burstTime > 0, push to Queue
> >
> > log results
